#!/bin/bash
version="0.3.1"
# exit if instance already running
pcount=`pgrep --count bashbreak`
if [ $pcount -gt 1 ]
then
  echo "Another bashbreak instance is already running, kill it before starting a new one (type: pkill -9 bashbreak)."
  exit
fi

# default parameters
n_session=0 # number of work sessions, 0 means infinite
t_work=600 # work sprint time in seconds
t_short_break=60 # short break in seconds
t_long_break=900 # long break in seconds
n_short_break=4 # number of short breaks before long break
verbose=false

# define functions
function help() {
  echo "bashbreak v. ${version}"
  echo "Use:"
  echo "	bashbreak [OPTION]..."
  echo "Options:"
  echo "	-n		Specify number of work sessions"
  echo "	-h		Print this help"
  echo "	-v		Verbose. Print messages to console"
  echo "	-b		Set number of short breaks"
  echo "	-s		Set short break duration"
  echo "	-l		Set long break duration"
  echo "	-w		Set work sprint duration"
}

function convert_time() {
  # convert time to ms or min
  (( t_work_min=t_work/60 ))
  (( t_short_break_ms=t_short_break*1000 ))
  (( t_long_break_ms=t_long_break*1000 ))
  (( t_long_break_min=t_long_break/60 ))
}

function echo_v() {
  # prints message if verbose option set
  local msg="${@}"
  if [[ "${verbose}" == true ]]; then
    echo "${msg}"
  fi
}

function short_break() {
  for i in `seq 1 $n_short_break`; do
    msg="Take a $t_short_break s break. ($i/$1)"
    sleep $t_work
    echo_v "`date +"%H:%M"` $msg" >&1
    notify-send "bashbreak" "$msg" --expire-time="$t_short_break_ms" --hint=int:transient:1
    sleep $t_short_break
    # continue only if user is not idle (requires xprintidle)
    check_idle
  done
}

function long_break() {
  msg="Take a $t_long_break_min min break."
  echo_v "`date +"%H:%M"` $msg" >&1
  notify-send "bashbreak" "$msg" --expire-time="$t_long_break_ms" --hint=int:transient:1
  sleep $t_long_break
  check_idle
}

function check_idle() {
  if ! [ -x '$(command -v xprintidle)' ]; then
    t_idle=`xprintidle` # user idle time in ms
    (( t_idle_=$t_idle+1 ))
    while [ $t_idle_ -ge $t_idle ]; do
      sleep 1
      t_idle_=`xprintidle`
    done
  else
    echo '`date +"%H:%M"` xprintidle not found. Not checking for user idle.' >&2
  fi
  echo_v "`date +"%H:%M"` Starting next work sprint." >&1
}

# CLI loop
optstring=":hvn:b:s:l:w:"
while getopts $optstring OPT; do
  case $OPT in
    h) 
      help; exit;;
    v)
      # output status messages to stdout
      verbose=true;;
    n) 
      n_session=${OPTARG};;
	b)
      # change number of short breaks
      n_short_break=${OPTARG};;
	s)
	  # change length of short break
	  t_short_break=${OPTARG};;
    l)
      # change length of long break
	  t_long_break=${OPTARG};;
	w)
	  # change time of work sprint
	  t_work=${OPTARG};;
    \?)
      # print if unknown option supplied
	  echo "Invalid option: -${OPTARG}."
	  echo "Use -h to see available options."
      exit;;
    :)
      # print if no option arguments supplied
      printf '%b' "Option -""$OPTARG"" requires an argument.\n"
      exit;;
  esac
done

# main program
function main() {
  # make trap to notify on kill signal
  trap 'notify-send "bashbreak" "Terminating."; echo_v "`date +"%H:%M"` Terminating."; exit' SIGINT SIGTERM
  convert_time
  if [ $n_session -eq 0 ]; then
    start_msg="Starting work sessions with $t_work_min min work sprints and $t_short_break s short breaks $n_short_break times before a $t_long_break_min min long break."
  elif [ $n_session -eq 1 ]; then
    start_msg="Starting work session with $t_work_min min work sprints and $t_short_break s short breaks $n_short_break times before a $t_long_break_min min long break."
  else
    start_msg="Starting $n_session work sessions with $t_work_min min work sprints and $t_short_break s short breaks $n_short_break times before a $t_long_break_min min long break."
  fi

  # send start message
  echo_v "`date +"%H:%M"` $start_msg" >&1
  notify-send "bashbreak" "$start_msg" --expire-time=10000 --hint=int:transient:1

  # main loop
  if [ $n_session -eq 0 ]; then
    while true; do
      short_break $n_short_break
      sleep $t_work
      long_break
    done
  else
    for i in `seq 1 $n_session`; do
      short_break $n_short_break
      sleep $t_work
      long_break
    done
  fi
}

main
exit
