#!/bin/bash
version="0.2.1"
# exit if instance already running
pcount=`pgrep --count bashbreak`
if [ $pcount -gt 1 ]
then
  echo "Another bashbreak instance is already running, kill it before starting a new one (type: pkill -9 bashbreak)."
  exit
fi

# default parameters
n_session=0 # number of work sessions, 0 means infinite
t_work=600 # work sprint time in seconds
t_short_break=60 # short break in seconds
t_long_break=900 # long break in seconds
n_short_break=4 # number of short breaks before long break
quiet=false

# convert time to ms or min
(( t_work_min=t_work/60 ))
(( t_short_break_ms=t_short_break*1000 ))
(( t_long_break_ms=t_long_break*1000 ))
(( t_long_break_min=t_long_break/60 ))

# define functions
help() {
  printf '%b\n' "bashbreak v. $version\n\nUse:\n\tbashbreak [OPTION]... \n\nOptions:\n -n\t\tSpecify number of work sessions\n -h\t\tPrint this help\n -q\t\tQuiet mode (no output to stdout)"
}

short_break() {
  for i in `seq 1 $n_short_break`; do
    msg="Take a $t_short_break s break. ($i/$1)"
    sleep $t_work
    echo "`date +"%H:%M"` $msg" >&1
    notify-send "bashbreak" "$msg" --expire-time="$t_short_break_ms" --hint=int:transient:1
    sleep $t_short_break
    # continue only if user is not idle (requires xprintidle)
    check_idle
  done
}

long_break() {
  msg="Take a $t_long_break_min min break."
  echo "`date +"%H:%M"` $msg" >&1
  notify-send "bashbreak" "$msg" --expire-time="$t_long_break_ms" --hint=int:transient:1
  sleep $t_long_break
  check_idle
}

check_idle() {
  if ! [ -x '$(command -v xprintidle)' ]; then
    t_idle=`xprintidle` # user idle time in ms
    (( t_idle_=$t_idle+1 ))
    while [ $t_idle_ -ge $t_idle ]; do
      sleep 1
      t_idle_=`xprintidle`
    done
  else
    echo '`date +"%H:%M"` xprintidle not found. Not checking for user idle.' >&2
  fi
  echo "`date +"%H:%M"` Starting next work sprint." >&1
}

# CLI loop
while getopts ":n::hq" OPT ; do
  case $OPT in

    h) # print help and exit
    help; exit;;

    n)
    n_session=$OPTARG;;

    q) # suppress output to stdout
    quiet=true;;

    \?) # print if unknown option supplied
    printf '%b' "Invalid option: -""$OPTARG""\n\n"
    help; exit;;

    :) # print if no option arguments supplied
    printf '%b' "Option -""$OPTARG"" requires an argument.\n"
    exit;;

  esac
done

# main program
main() {
  # make trap to notify on kill signal
  trap 'notify-send "bashbreak" "Terminating."; echo "`date +"%H:%M"` Terminating."; exit' SIGINT SIGTERM

  if [ $n_session -eq 0 ]; then
    start_msg="Starting work sessions with $t_work_min min work sprints and $t_short_break s short breaks $n_short_break times before a $t_long_break_min min long break."
  elif [ $n_session -eq 1 ]; then
    start_msg="Starting work session with $t_work_min min work sprints and $t_short_break s short breaks $n_short_break times before a $t_long_break_min min long break."
  else
    start_msg="Starting $n_session work sessions with $t_work_min min work sprints and $t_short_break s short breaks $n_short_break times before a $t_long_break_min min long break."
  fi

  # send start message
  if [ $quiet = false ]; then
    echo "`date +"%H:%M"` $start_msg" >&1
  fi
  notify-send "bashbreak" "$start_msg" --expire-time=10000 --hint=int:transient:1

  # main loop
  if [ $n_session -eq 0 ]; then
    while true; do
      short_break $n_short_break
      sleep $t_work
      long_break
    done
  else
    for i in `seq 1 $n_session`; do
      short_break $n_short_break
      sleep $t_work
      long_break
    done
  fi
}

main
exit
