#!/bin/bash
version="0.6.3"

# source config file
if [ -e "$HOME/.config/bashbreak/bashbreak.conf" ]; then 
	. "$HOME/.config/bashbreak/bashbreak.conf"
elif [ -e "/etc/bashbreak/bashbreak.conf" ]; then 
	. "/etc/bashbreak/bashbreak.conf"
else
	. ./bashbreak.conf || exit 1
fi

# define functions
function help() {
  echo "bashbreak v. ${version}"
  echo "Use:"
  echo "	bashbreak [OPTION]..."
  echo "Options:"
  echo "	-n		Specify number of work sessions"
  echo "	-h		Print this help"
  echo "	-B		Run session in background"
  echo "	-s		Print status message"
  echo "	-q		Quit a running session"
}

function print_start_msg() {
  # adapt start msg to number of sessions
  if [ "$n_session" -eq 0 ]; then
    start_msg="Starting work sessions with $t_work min work sprints and $t_short_break min short breaks $n_short_break times before a $t_long_break min long break."
  elif [ "$n_session" -eq 1 ]; then
    start_msg="Starting work session with $t_work min work sprints and $t_short_break min short breaks $n_short_break times before a $t_long_break min long break."
  else
    start_msg="Starting $n_session work sessions with $t_work min work sprints and $t_short_break min short breaks $n_short_break times before a $t_long_break min long break."
  fi
  echo_v "$(date +'%H:%M') $start_msg"
  notify-send "bashbreak" "$start_msg" --expire-time=10000 --hint=int:transient:1
}

function convert_time() {
  # convert time to ms or min
  (( t_work_s=t_work*60 ))
  (( t_short_break_s=t_short_break*60 ))
  (( t_short_break_ms=t_short_break_s*1000 ))
  (( t_long_break_s=t_long_break*60 ))
  (( t_long_break_ms=t_long_break_s*1000 ))
}

function echo_v() {
  # print message if verbose option set
  local msg="${*}"
  if [[ "${verbose}" == true ]]; then
    echo "${msg}" >&1
  fi
}

function pretty_time() {
  # takes a time in s and displays it in min and s
  min=$(( $1 / 60 ))
  sec=$(( $1 % 60 ))
  echo "$min min $sec s"
}

function sleep_and_log() {
  # first argument is time in s
  t_sleep="$1"
  next_event="$2"
  j=0
  while [ $j -le $t_sleep ]; do 
    sec_remaining=$(( $t_sleep - $j ))
	log_msg="$(pretty_time $sec_remaining) until next $next_event."
	write_mem "$log_msg" 
    sleep 1
	let "j+=1"
  done
}

function short_break() {
  # short break and work sprint loop. $1 sets number of breaks
  for i in $(seq 1 "$1"); do

    # check what next event is
	n=$(( $1 - $i )) 
    if [ $n -ge 1 ]; then
	  next_event="short break"
    else
	  next_event="long break"
	fi

    n_work_sprint="$(( $1 - 1 ))" 
	sprint_frac="$i/$n_work_sprint"

	# start next work sprint
	sleep_and_log "$t_work_s" "$next_event"

	# start short break
	short_break_frac="$i/$1"
    msg="Take a $t_short_break min break. ($short_break_frac)"
    echo_v "$(date +'%H:%M') $msg"
    notify-send "bashbreak" "$msg" --expire-time="$t_short_break_ms" --hint=int:transient:1
	next_event="work sprint"
	sleep_and_log "$t_short_break_s" "$next_event"

    # continue only if user is not idle (requires xprintidle)
    check_idle
  done
}

function long_break() {
  # long break loop
  msg="Take a $t_long_break min break."
  echo_v "$(date +'%H:%M') $msg"
  notify-send "bashbreak" "$msg" --expire-time="$t_long_break_ms" --hint=int:transient:1
  sleep_and_log "$t_long_break_s" "work sprint"
  check_idle
}

function check_idle() {
  # check if user idle
  if [ -x "$(command -v xprintidle)" ]; then
    t_idle=$(xprintidle) # user idle time in ms
	if [ "$t_idle" -gt 5000 ]; then
      (( t_idle_=t_idle+1 ))
      while [ "$t_idle_" -ge "$t_idle" ]; do
	    write_mem "User idle"
        sleep 1
        t_idle_=$(xprintidle)
      done
	fi
  else
    echo "$(date +'%H:%M') xprintidle not found. Not checking for user idle." >&2
  fi
  echo_v "$(date +'%H:%M') Starting next work sprint."
  notify-send "bashbreak" "Starting next work sprint."
}

function create_mem() {
  # create temp file in memory
  mem="$(mktemp /dev/shm/bashbreak.XXX)" 
}

function write_mem() {
  # write status to mem file
  echo "$@" > "$mem"
}

function clear_mem() {
  # clear temp mem file
  rm -f /dev/shm/bashbreak.*
}

function kill_running() {
  # clear memory and kill running instance
  notify-send "bashbreak" "Terminated."
  echo_v "`date +"%H:%M"` Terminated."
  clear_mem
  pkill -9 "bashbreak"
}

# exit if instance already running
pcount=$(pgrep --count bashbreak)
if [ "$pcount" -gt 1 ]; then
  # start cropped CLI loop
  while getopts ":hqs" OPT; do
	case $OPT in
	  h)
        help; exit;;
	  s)
		# print status
		tmp_file="$(ls -1tr /dev/shm/bashbreak.* | tail -n 1)"
		status_msg="$(cat "$tmp_file")"
		echo "$status_msg"
		notify-send "bashbreak" "$status_msg"
		exit;;
	  q)
		kill_running;;
	  \?)
	    echo "Another bashbreak instance is already running, quit it before starting a new one (type: bashbreak -q)."
		exit;;
	esac
  done
  echo "Another bashbreak instance is already running, quit it before starting a new one (type: bashbreak -q)."
  exit
fi

# main CLI loop
optstring=":hn:b:Bq"
while getopts $optstring OPT; do
  case $OPT in
    h)
      help; exit;;
    n)
      n_session=${OPTARG};;
    B)
	  # fork process to background
      fork_to_bg=true;;
	q)
	  kill_running;;
    \?)
      # print if unknown option supplied
      echo "Invalid option: -${OPTARG}."
      echo "Use -h to see available options."
      exit;;
    :)
      # print if no option arguments supplied
      echo "Option -${OPTARG} requires an argument."
      exit;;
  esac
done

# main program
function main() {
  # make trap to notify and clear mem on kill signal
  trap 'notify-send "bashbreak" "Terminated."; echo_v "`date +"%H:%M"` Terminated."; clear_mem; exit' SIGINT SIGTERM
  convert_time
  print_start_msg
  # main loop
  create_mem
  if [ "$n_session" -eq 0 ]; then
    # infinite number of sessions
    while true; do
      short_break "$n_short_break"
      sleep_and_log "$t_work_s"
      long_break
    done
  else
	# finite number of sessions
    for i in $(seq 1 "$n_session"); do
      short_break "$n_short_break"
      sleep_and_log "$t_work_s"
      long_break
    done
  fi
  clear_mem
}

# check whether to run main in background or foreground
if [ "$fork_to_bg" == true ]; then
  {
    trap "" HUP
    main
  } < /dev/null > /dev/null 2>&1 &
else
  main
fi

exit
